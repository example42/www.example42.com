---
layout: default
title: !binary |-
  U3BvbnNvciBFeGFtcGxlNDIgbW9kdWxlcyBkZXZlbG9wbWVudA==
created: 1365008822
---
<div>I recently posted a comment about the evolution of Example42 modules in the Example42 Puppet Modules Google group.</div><div>&nbsp;</div><div>It contains my opinions on how modules should be and how could evolve the new generation of Puppet modules.</div><div>&nbsp;</div><div>I repost it here, as it gives a good overview of my current ideas and the evolution of Example42 modules.</div><div>&nbsp;</div><div>---&nbsp;</div><div>&nbsp;</div><div>Let&#39;s move.</div><div>This is not something that I can do alone.</div><div>NextGen modules are there, somehow stable, doing their work.</div><div>They are requiring a lot of support that I can&#39;t give in my free time.</div><div>Even for testing submitted patches.</div><div>&nbsp;</div><div>We have to start to work on brand new 3.x modules and a sane ecosystem.</div><div>&nbsp;</div><div>I suggest these principles:</div><div>0- No NextGen legacies&nbsp;</div><div>1- Real single point of responsability for modules</div><div>2- Higher abstraction &nbsp;stack modules</div><div>3- Follow stdmod naming conventions</div><div>4- Distributed development (modules maintainers)</div><div>5- Implementation and usage patterns coherency</div><div>&nbsp;</div><div>&nbsp;</div><div>0- No NextGen legacies</div><div>&nbsp;</div><div>The current NextGen modules should not be taken as reference, no needs to have backwards compatibility.</div><div>Let&#39;s take the good things (defines, implementation patterns, correct params and setups for different OS ) and build from them.</div><div>Let&#39;s cut all the parameters and functionalities that don&#39;t fit with points 1 and 3.</div><div>&nbsp;</div><div>&nbsp;</div><div>1- Real single point of responsability for modules</div><div>&nbsp;</div><div>This is important and critical for the whole long term feasibility and reusability of the modules:</div><div>an application module should only expose what&#39;s needed to configure and manage its application.</div><div>No relation to third modules, no options to provide implementation logics of higher abstractions.</div><div>For example, an apache main class should expose just the essential parameters to just manage (in a reusable way) the application.</div><div>Then the module may have custom defines to manage modules, virtualhosts, users, or whatever.</div><div>We can reuse the good ones around, adapting the parameters to stdmod conventions.</div><div>It might even have something like apache::passenger, with its own parameters, but is should not expose any passenger related parameter in the main class.</div><div>I would add to these basic parameters the ones need to firewall and monitor them, keeping them in the most simple and open way, just 2 parameters:</div><div>$monitor_class - The name of the class to use to manage monitoring.</div><div>$monitor_config_hash - An open to any option configuration hash (we may stanrdardize it when working on the new monitor / firewall implementations )&nbsp;</div><div>Same for $firewall_</div><div>I&#39;d also provide in each module (that needs them) standard &quot;general purpose&quot; defines to:</div><div>- Manage single configuration files (useful when multiple config files are needed and you don&#39;t want to clutter the main class params to manage them)</div><div>- Manage single configuration entries (via augeas?)</div><div>No read need, IMHO, to have different defines with specific parameters for different configuration files, just assure there&#39;s a &quot;catchall&quot; config_hash parameter.</div><div>So just dumb interfaces to the application&#39;s configuration , all the logic and the implementation details can be provided by 2:</div><div>This would allow quick creation of basic modules with at least these &quot;minimal&quot; features, then we can add or import more specific ones.&nbsp;</div><div>Here we have to place rspec tests, rspec-system tests and essential documentation (all the stdmod standards related one can be avoided, imho)</div><div>&nbsp;</div><div>2- Higher abstraction &nbsp;stack modules</div><div>&nbsp;</div><div>Here we move all the logic to manage modules interdipendences and integrations.</div><div>So we might have modules like:</div><div>puppet-stack_lamp</div><div>puppet-stack_liferay (but also just puppet-liferay as long as it follows stacks&#39; patterns)</div><div>puppet-stack_rails</div><div>puppet-stack_logs ( here&#39;s a sample https://github.com/example42/puppet-stack/blob/master/manifests/logs.pp )</div><div>puppet-stack_puppetinfrastructure ( https://github.com/example42/puppet-stack_puppet &nbsp;)&nbsp;</div><div>Stacks do, in some way, what we often do in our puppet setups (and have called them roles, hostgroups, profiles) exposing higher level parameters that allow and manage the logic provided by the stack to integrate different application modules.</div><div>They are supposed to be used by nodes doing different things which are needed to build the stack.</div><div>In stacks some parameters could be managed in automatic ways, based on the nodes who use their single components.</div><div>With puppetdbquery some wonderful things could be done.</div><div>The parameters exposed by a stack class should be about:</div><div>- if to include a specific application in the node ( install_webserver ?)</div><div>- what to use for each stack&#39;s application (where alternatives are provided) ( webserver_name ? ),</div><div>- how to configure them (parameters hash, custom template files )</div><div>- endpoints, credentials, urls&hellip;</div><div>Stacks are the place for integration tests.&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>3- Follow stdmod naming conventions</div><div>&nbsp;</div><div>They are still not definitive, I really urge whoever is interested in a good shared modules ecosystem to contribute actively to https://github.com/stdmod</div><div>We definitively need to decide on few remaining things, IMHO, like:</div><div>file (file_path? config_file? config?) (1)</div><div>file_source (source? config_file_source? config_source?)</div><div>file_template (template? config_file_template? config_template?...)</div><div>Since we are doing this as users of Ex42 modules we might decide to choose the current names for the most used parameters (template? source?) as long as they make sense in the whole stdmod picture.</div><div>&nbsp;</div><div>&nbsp;</div><div>4- Distributed development (modules maintainers)</div><div>&nbsp;</div><div>This can&#39;t be an Example42&#39;s only work. I can&#39;t and don&#39;t want to manage multiple dozens of modules of applications I don&#39;t know or use.</div><div>Once good blueprints are available for different kind of modules, we can quickly create new modules based on them, adding and adapting the available defines, facts, functions from nextgen and &nbsp;other open source modules.</div><div>Possibly involving the relevant authours, also as maintainers.</div><div>Code can stay in each maintainer&#39;s repos , Dolf, I, whoever can manage their own collections of stdmodules and stacks, pointing to gitsubmodules at the desired version / head (or managing them in a single big git repo)</div><div>Of course just one &quot;stdmod&quot; module for application would be the ideal: forks just for pulling back to upstream, as managed by the official maintainer(s).</div><div>All this, strictly following point 5:</div><div>&nbsp;</div><div>&nbsp;</div><div>5- Implementation and usage patterns coherency</div><div>&nbsp;</div><div>It&#39;s very important to keep coherency inside the modules set, both for naming and usage patterns.</div><div>For this the sooner the finalize naming standars and we have good samples and &nbsp;templates, the better.</div><div>I would stick the code of the modules for Puppet 3 compatibility, no need to do now things that support older versions and too early to embrace fully Puppet 4 ( &gt; 3.3) only &nbsp;features (data in modules, future parser, containers&hellip; ).</div><div>They will be useful probably to manage in a smart way firewalling and monitoring, but given the simple basic layout.</div><div>For this reason I would leave open parameters like monitor_class or monitor_config_hash that may adapt to any future evolution.</div><div>&nbsp;</div><div>&nbsp;</div><div>Next steps&hellip;</div><div>- propose blueprints for common &nbsp;module&#39;s layout.</div><div>- make quick and easy common usage, single package modules (to just &quot;include&quot;): zip, wget, git&hellip;</div><div>- make essential modules (to improve with time) for the most cross used apps: apache, nginx, mysql&hellip;</div><div>- explore stacks</div><div>my2c</div><div>Al</div>
